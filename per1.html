<!DOCTYPE html>
<html lang="id">
<head>
    <link rel="stylesheet" href="style.css">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Materi Pertemuan 1 - Pengenalan Grafika Komputer (Standalone - Matched)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
</head>
<body>
    <!-- Sidebar Structure from index.html -->
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <h3><i class="fas fa-graduation-cap"></i> Menu</h3>
            <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        </div>
        <!-- Links adjusted for standalone context (assuming it's in root or /pertemuan) -->
        <!-- If in root, use "index.html", "pertemuan/perX.html" -->
        <!-- If in /pertemuan, use "../index.html", "perX.html" -->
        <!-- Assuming it will be placed in /pertemuan folder -->
        <a href="index.html" class="menu-item "><i class="fas fa-chart-pie"></i> DASHBOARD</a>
        <a href="per1.html" class="menu-item active"><i class="fas fa-book"></i> Pertemuan 1</a>
        <a href="per2.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 2</a>
        <a href="per3.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 3</a>
        <a href="per4.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 4</a>
        <a href="per5.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 5</a>
        <a href="per6.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 6</a>
        <a href="per7.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 7</a>
        <a href="per8.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 8</a>
        <a href="per9.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 9</a>
        <a href="per10.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 10</a>
        <a href="per11.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 11</a>
        <a href="per12.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 12</a>
        <a href="per13.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 13</a>
        <a href="per14.html" class="menu-item "><i class="fas fa-book"></i> Pertemuan 14</a>
    </div>

    <!-- Main Content Structure from index.html -->
    <div id="main">
        <button class="openbtn" onclick="openNav()"><i class="fas fa-bars"></i> Menu</button>
        <div id="content-container">
            <!-- Pertemuan 1 Content -->
            <div class="pertemuan-content-area">
                <h1>Pertemuan 1: Pengenalan Grafika Komputer</h1>

                <h2>A. Tujuan Pembelajaran</h2>
                <p>Setelah menyelesaikan materi pada pertemuan ini, mahasiswa diharapkan mampu memahami konsep dasar grafika komputer. Topik yang akan dibahas meliputi:</p>
                <ul>
                    <li>Pengantar Grafika Komputer</li>
                    <li>Gambaran Umum Mata Kuliah Grafika Komputer</li>
                    <li>Pengertian Pixel</li>
                </ul>

                <h2>B. Uraian Materi</h2>

                <h3>1. Pengantar Grafika Komputer</h3>
                <h4>a. Pengertian Grafika Komputer</h4>
                <p>Teknologi dan perkembangan ilmu saat ini sangat pesat. Setiap aspek kehidupan dipengaruhi oleh informasi yang diperoleh melalui ilmu teknologi dan pengetahuan. Komputer, sebagai mesin yang dapat diinstruksikan untuk menjalankan operasi aritmatika atau logika secara otomatis melalui pemrograman, telah berkembang pesat dalam mengolah data, baik dari segi kecepatan maupun kapasitas. Data yang diolah tidak hanya berupa angka atau teks, tetapi komputer juga dapat mengolah gambar atau grafika. Ilmu yang mempelajari pengolahan grafis ini disebut <strong>Grafika Komputer</strong>.</p>
                <p>Grafika komputer dapat didefinisikan sebagai ilmu dan seni berkomunikasi secara visual melalui tampilan komputer dan perangkat interaksinya. Aspek visual ini umumnya berjalan dari komputer ke manusia, sementara interaksi manusia ke komputer dimediasi oleh perangkat seperti mouse, keyboard, atau joystick. Namun, dengan berkembangnya visi komputer, data visual kini juga dapat mengalir kembali ke komputer.</p>
                <p>Karena manusia adalah konsumen utama komunikasi visual ini, cara manusia memandang citra sangat penting dalam desain grafis. Grafika komputer adalah bidang lintas disiplin yang melibatkan fisika (untuk model cahaya dan simulasi animasi), matematika (untuk mendeskripsikan bentuk), persepsi manusia (untuk alokasi sumber daya), teknik (untuk optimasi bandwidth, memori, waktu prosesor), serta desain grafis dan seni (untuk menciptakan komunikasi visual yang efektif).</p>
                <p>Secara sempit, grafika komputer mengambil model objek dalam sebuah adegan (deskripsi geometris dan reflektansi cahaya) dan model cahaya yang dipancarkan, kemudian menghasilkan representasi pandangan tertentu dari adegan tersebut. Proses ini melibatkan perhitungan kompleks tentang bagaimana cahaya berinteraksi dengan objek dan mencapai 'kamera' imajiner. Sebaliknya, visi komputer mencoba memahami adegan dari gambar yang ada.</p>

                <h4>b. Sejarah Grafika Komputer</h4>
                <p>Sejarah komunikasi grafis sudah ada sejak zaman kuno (Yunani, Roma, Mesir). Perkembangan grafika komputer modern dapat dibagi menjadi beberapa fase:</p>
                <ul>
                    <li><strong>Fase Pertama (1950-1960):</strong> Munculnya tampilan grafis Vectorscope di MIT, penggunaan pena cahaya pertama, dan pemrosesan gambar foto pertama.</li>
                    <li><strong>Fase Kedua (1960-1970):</strong> Sistem komunikasi grafis manusia-mesin di MIT, pengembangan komputer analog untuk manipulasi gambar, komputer grafis komersial pertama (IBM 2250), game grafis pertama ("Odyssey"), dan animasi komputer pertama ("FLEXIPEDE").</li>
                    <li><strong>Fase Ketiga (1970-1980):</strong> Pengembangan algoritma Z-buffer dan pemetaan tekstur, sistem animasi Tween oleh Edwin Catmull, film dengan penampilan 3D pertama, dan penggunaan komputer digital pertama dalam grafika komputer (DEC).</li>
                    <li><strong>Fase Keempat (1980-1990):</strong> Penggunaan luas animasi grafis 3D dalam film (Disney), peluncuran AutoCAD 1.0, perangkat lunak pencitraan medis dengan teknologi Voxel, dan pengenalan standar Video Graphics Array (VGA).</li>
                </ul>

                <h3>2. Gambaran Umum Mata Kuliah Grafika Komputer</h3>
                <p>Grafika komputer adalah cabang ilmu komputer yang berhubungan dengan menghasilkan gambar dengan bantuan komputer. Ini adalah teknologi inti dalam fotografi digital, film, permainan video, layar perangkat seluler dan komputer, serta banyak aplikasi khusus lainnya. Bidang ini didukung oleh ilmu lain seperti matematika, geometri, analisis numerik, dan ilmu komputasi.</p>
                <!-- Placeholder for Table 1.1 if needed -->

                <h4>a. Peranan dan Penggunaan Grafika Komputer</h4>
                <p>Grafika komputer digunakan secara luas di berbagai bidang seperti ilmu pengetahuan, industri, kedokteran, bisnis, teknik, pemerintahan, seni, hiburan, pendidikan, dan periklanan.</p>

                <h4>b. Aplikasi-aplikasi Grafika Komputer</h4>
                <p>Beberapa area aplikasi utama meliputi:</p>
                <ul>
                    <li><strong>Computer Art:</strong> Seni rupa dan komersial, desain objek, animasi kartun, logo.</li>
                    <li><strong>Computer Aided Drawing (CAD):</strong> Perancangan bangunan, mobil, pesawat dengan detail dan akurasi tinggi.</li>
                    <li><strong>Presentation Graphics:</strong> Pembuatan grafik dan diagram untuk laporan keuangan, statistik, ilmiah.</li>
                    <li><strong>Entertainment:</strong> Industri film (efek visual, animasi) dan game.</li>
                    <li><strong>Education:</strong> Pembuatan model visual untuk pembelajaran yang mudah dipahami.</li>
                    <li><strong>Training:</strong> Simulator untuk pelatihan (misalnya, penerbangan).</li>
                    <li><strong>Visualisation:</strong> Visualisasi data untuk menemukan wawasan dan memahami proses kompleks.</li>
                    <li><strong>Image Processing:</strong> Pengeditan dan peningkatan kualitas gambar.</li>
                    <li><strong>Machine Drawing:</strong> Perancangan bagian mesin dengan presisi tinggi.</li>
                    <li><strong>Graphical User Interface (GUI):</strong> Menciptakan antarmuka pengguna yang intuitif dan mudah digunakan.</li>
                </ul>

                <h4>c. Perkakas Grafika Komputer</h4>
                <p>Pengembangan grafika komputer memerlukan sumber daya manusia, perangkat keras (Komputer, Display, Printer, Monitor, Webcam), dan perangkat lunak.</p>
                <p>Contoh perangkat lunak:</p>
                <ul>
                    <li><strong>Sistem Operasi:</strong> Windows, macOS, Linux.</li>
                    <li><strong>Aplikasi Desain/Edit:</strong> Adobe Illustrator, Photoshop, GIMP, Inkscape.</li>
                    <li><strong>Animasi:</strong> Blender, 3ds Max, Maya, FlipaClip.</li>
                    <li><strong>Visualisasi:</strong> Matlab, Maple, Python (Matplotlib, Plotly).</li>
                    <li><strong>Virtual Reality (VR) / Augmented Reality (AR):</strong> Unity, Unreal Engine.</li>
                    <li><strong>Pemrograman:</strong> Berbagai bahasa (C++, Java, Python) dengan library grafis (OpenGL, DirectX, Vulkan, WebGL).</li>
                </ul>
                <p>Istilah penting: vector graphics, pixel, LED, LCD, CRT, VGA, JPG, GIF, Bitmap, Resolusi, Animasi, Modeling, Wireframe, Rendering.</p>

                <h4>d. Teknologi Output</h4>
                <p>Perangkat keras dan lunak memungkinkan penyajian bentuk 2D dan 3D.</p>
                <ul>
                    <li><strong>Teknologi Display:</strong> Berkembang dari sistem elektromekanis ke perangkat elektronik modern (CRT, Plasma, LCD, TFT, LED, OLED) yang mampu menampilkan jutaan elemen gambar individual (piksel).</li>
                    <li><strong>Random-scan Display (Vector Display):</strong> Mengarahkan berkas elektron hanya ke area gambar yang perlu digambar, baris per baris. Contoh: Pen plotter. Kecepatan refresh tergantung jumlah baris.</li>
                    <li><strong>Monitor Color CRT:</strong> Menggunakan lapisan fosfor berbeda atau kelompok titik fosfor (merah, hijau, biru) yang ditembak oleh satu atau tiga berkas elektron untuk menghasilkan warna.</li>
                </ul>
                
                <h3>3. Pengertian Pixel</h3>
                <p><strong>Pixel</strong> (singkatan dari <i>Picture Element</i>) adalah unit terkecil dari gambar digital atau grafis yang dapat ditampilkan dan diwakili pada perangkat tampilan digital. Setiap pixel adalah sampel dari gambar asli; lebih banyak sampel biasanya memberikan representasi yang lebih akurat dari aslinya. Intensitas setiap pixel bervariasi; dalam sistem warna, setiap pixel biasanya memiliki tiga atau empat komponen intensitas seperti merah, hijau, dan biru (RGB), atau cyan, magenta, kuning, dan hitam (CMYK).</p>
                <p>Gambar terdiri dari matriks (grid) piksel. Semakin banyak piksel yang digunakan untuk merepresentasikan gambar, semakin dekat hasilnya menyerupai aslinya. Jumlah piksel dalam suatu gambar disebut <strong>resolusi</strong>.</p>

                <!-- Interactive Pixel Grid Section -->
                <div class="interactive-section">
                    <h3>Interaktif: Simulasi Grid Pixel</h3>
                    <p>Klik atau geser sambil menekan tombol mouse untuk "menggambar" dengan mengubah warna pixel individual.</p>
                    <div class="controls">
                        <label for="colorPicker">Pilih Warna:</label>
                        <div class="color-picker-container">
                            <input type="color" id="colorPicker" value="#667eea">
                        </div>
                        <button class="brsk" onclick="clearGrid()">Bersihkan Grid</button>
                        <label for="gridSize">Ukuran Grid:</label>
                        <select id="gridSize" onchange="resizeGrid()">
                            <option value="10">10x10</option>
                            <option value="20" selected>20x20</option>
                            <option value="30">30x30</option>
                            <option value="40">40x40</option>
                        </select>
                    </div>
                    <canvas id="pixelCanvas" width="400" height="400"></canvas>
                    <div class="info" id="pixelInfo">Koordinat: -, Warna: -</div>
                </div>
                <!-- End Interactive Pixel Grid Section -->

            </div> <!-- End .pertemuan-content-area -->
        </div> <!-- End #content-container -->
    </div> <!-- End #main -->

    <!-- Embedded JavaScript -->
    <script>
        /* --- Sidebar Navigation --- */
        function openNav() {
            const sidebar = document.getElementById("sidebar");
            const main = document.getElementById("main");
            if (sidebar) sidebar.style.width = "250px";
            if (main && window.innerWidth > 768) {
                 main.style.marginLeft = "250px";
            }
        }

        function closeNav() {
            const sidebar = document.getElementById("sidebar");
            const main = document.getElementById("main");
            if (sidebar) sidebar.style.width = "0";
            if (main) main.style.marginLeft = "0";
        }

        /* --- Pixel Grid Script --- */
        const canvas = document.getElementById("pixelCanvas");
        const ctx = canvas.getContext("2d");
        const colorPicker = document.getElementById("colorPicker");
        const gridSizeSelect = document.getElementById("gridSize");
        const pixelInfoDiv = document.getElementById("pixelInfo");
        
        let gridSize = parseInt(gridSizeSelect.value);
        let pixelSize = canvas.width / gridSize;
        let gridData = createGridData(gridSize);
        let isMouseDown = false; // Track mouse button state

        function createGridData(size) {
            let data = [];
            for (let y = 0; y < size; y++) {
                data[y] = [];
                for (let x = 0; x < size; x++) {
                    data[y][x] = "#ffffff"; // Default white
                }
            }
            return data;
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw colored squares first
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    ctx.fillStyle = gridData[y][x];
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
            // Draw grid lines on top
            ctx.strokeStyle = "#eee";
            ctx.lineWidth = 1;
            for (let i = 0; i <= gridSize; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(i * pixelSize, 0);
                ctx.lineTo(i * pixelSize, canvas.height);
                ctx.stroke();
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, i * pixelSize);
                ctx.lineTo(canvas.width, i * pixelSize);
                ctx.stroke();
            }
        }

        function clearGrid() {
            gridData = createGridData(gridSize);
            drawGrid();
            pixelInfoDiv.textContent = "Koordinat: -, Warna: -";
        }

        function resizeGrid() {
            gridSize = parseInt(gridSizeSelect.value);
            pixelSize = canvas.width / gridSize;
            clearGrid();
        }

        // Function to handle coloring a pixel
        function colorPixel(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            const gridX = Math.floor(canvasX / pixelSize);
            const gridY = Math.floor(canvasY / pixelSize);

            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
                const selectedColor = colorPicker.value;
                // Only redraw if the color is different
                if (gridData[gridY][gridX] !== selectedColor) {
                    gridData[gridY][gridX] = selectedColor;
                    ctx.fillStyle = selectedColor;
                    ctx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);
                    // Redraw border lines around the pixel
                    ctx.strokeStyle = "#eee";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);
                }
                // Update info regardless of color change
                pixelInfoDiv.textContent = `Koordinat: (${gridX}, ${gridY}), Warna: ${selectedColor}`;
            }
        }

        // Mouse Events
        canvas.addEventListener("mousedown", function(event) {
            isMouseDown = true;
            colorPixel(event);
        });

        canvas.addEventListener("mouseup", function() {
            isMouseDown = false;
        });

        canvas.addEventListener("mouseleave", function() {
            isMouseDown = false; // Stop drawing if mouse leaves canvas
            pixelInfoDiv.textContent = "Koordinat: -, Warna: -";
        });

        canvas.addEventListener("mousemove", function(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            const gridX = Math.floor(canvasX / pixelSize);
            const gridY = Math.floor(canvasY / pixelSize);

            if (isMouseDown) {
                colorPixel(event); // Color if mouse is down
            } else {
                // Update info only if mouse is not down
                if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
                    const currentColor = gridData[gridY][gridX];
                    pixelInfoDiv.textContent = `Koordinat: (${gridX}, ${gridY}), Warna: ${currentColor}`;
                } else {
                    pixelInfoDiv.textContent = "Koordinat: -, Warna: -";
                }
            }
        });

        // Touch Events (Basic Support)
        canvas.addEventListener("touchstart", function(event) {
            event.preventDefault(); // Prevent scrolling
            isMouseDown = true;
            colorPixel(event);
        });

        canvas.addEventListener("touchend", function(event) {
            event.preventDefault();
            isMouseDown = false;
        });

        canvas.addEventListener("touchcancel", function(event) {
            event.preventDefault();
            isMouseDown = false;
        });

        canvas.addEventListener("touchmove", function(event) {
            event.preventDefault(); // Prevent scrolling
            if (isMouseDown) {
                colorPixel(event);
            }
        });

        /* --- Standalone Page Initialization --- */
        document.addEventListener("DOMContentLoaded", () => {
            console.log("Standalone page loaded. Initializing...");
            const menuItems = document.querySelectorAll(".sidebar .menu-item");

            // Ensure sidebar links work for direct navigation
            menuItems.forEach(item => {
                // Remove any potential conflicting click listeners 
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
            });

            // Ensure the correct sidebar item is marked active based on URL
            // Since this IS per1.html, we activate the per1 link.
            const activeItem = document.querySelector('.sidebar a.menu-item[href="per1.html"]');
            if (activeItem) {
                menuItems.forEach(i => i.classList.remove("active"));
                activeItem.classList.add("active");
            } else {
                console.warn("Could not find active menu item for per1.html");
            }
            
            // Initial draw for pixel grid
            drawGrid();
        });

    </script>

</body>
</html>
